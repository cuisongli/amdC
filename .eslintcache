[{"D:\\workspace\\create-pdman\\my_amad\\src\\index.js":"1","D:\\workspace\\create-pdman\\my_amad\\src\\App.js":"2","D:\\workspace\\create-pdman\\my_amad\\src\\reportWebVitals.js":"3","D:\\workspace\\create-pdman\\my_amad\\src\\App\\Immutable\\index.js":"4","D:\\workspace\\create-pdman\\my_amad\\src\\App\\Immutable\\Demo1.js":"5"},{"size":524,"mtime":1610008965312,"results":"6","hashOfConfig":"7"},{"size":528,"mtime":499162500000,"results":"8","hashOfConfig":"7"},{"size":362,"mtime":499162500000,"results":"9","hashOfConfig":"7"},{"size":10251,"mtime":1610432688828,"results":"10","hashOfConfig":"7"},{"size":91,"mtime":1610009257215,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"v3bxfx",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"17"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"26"},"D:\\workspace\\create-pdman\\my_amad\\src\\index.js",[],["27","28"],"D:\\workspace\\create-pdman\\my_amad\\src\\App.js",[],["29","30"],"D:\\workspace\\create-pdman\\my_amad\\src\\reportWebVitals.js",[],"D:\\workspace\\create-pdman\\my_amad\\src\\App\\Immutable\\index.js",["31"],"import React from 'react';\r\nimport Immutable, { fromJS, isIndexed } from 'immutable';\r\nimport {Map} from 'immutable';\r\nimport Cursor from 'immutable/contrib/cursor';\r\n/**\r\n\r\nImmutable\r\n\r\n背景\r\n    JavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始\r\n    对象，改变新的对象将影响到原始对象。如 foo={a: 1};bar=foo; bar.a=2 你会发现此时 foo.a 也被改成了2。\r\n    虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，Mutable 带来的优点变得得不偿失。\r\n    为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。\r\n\r\n介绍\r\n    Immutable就是在创建变量、赋值后便不可更改，若对其有任何变更，就会回传一个新值。\r\n\r\n\r\n原理\r\n    实现的原理是Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。\r\n    同时为了避免deepCopy把所有的节点都复制一遍带来的性能损耗，Immutable使用了Structural Sharing(结构共享)，即如果对象树\r\n    中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。\r\n------\r\n\r\n作用\r\n    1，让纯函数更强大，让开发愈发简单明了\r\n    2. 使类似于惰性求值的函数编程成为可能\r\n  优点\r\n    1.Immutable降低了Mutable带来的复杂度\r\n    2.节省内存\r\n        Immutable.js使用了Structure Sharing会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。\r\n    3.并发安全\r\n\r\n        数据天生不可变，不需要并发锁（JavaScript单线程运行）\r\n  缺点\r\n    1.需要学习新的API\r\n    2.增加了资源文件的大小\r\n    3.容易与原生对象混淆\r\n        Immutable中的Map和List虽对应原生Object和Array，但操作不同，用法是map.get('key')而不是map.key,array.get(0)而不是array[0]。\r\n        另外 Immutable 每次修改都会返回新对象，也很容易忘记赋值。\r\n       \r\n        解决方法\r\n            1.使用 Flow 或 TypeScript 这类有静态类型检查的工具。消除了Immutable流经系统的精神负担  ？？？？\r\n            2.约定变量命名规则：如所有 Immutable 类型对象以 $$ 开头。\r\n            3.使用 Immutable.fromJS 而不是 Immutable.Map 或 Immutable.List 来创建对象，这样可以避免 Immutable 和原生对象间的混用。\r\n            隐藏有关数据结构的详细信息。\r\n\r\n如何与React搭配使用，关键点是shouldComponentUpdate\r\nObject.freeze方法可以冻结一个对象。\r\n\r\n使用\r\n    immutable主要是防止state对象被错误赋值\r\n    Cursor\r\n        由于Immutable数据一般嵌套非常深，为了便于访问深层数据，Cursor提供了可以直接访问这个深层数据的引用。\r\n\r\n\r\n将TypeScript与Immutable.js v4一起使用\r\n\r\n实现机制\r\n我们新生成一个根节点，对于有修改的部分，把相应路径上的所有节点重新生成，对于本次操作没有修改的部分，我们可以直接把相应的旧的节点拷贝过去，这其实就是结构共享。这样每次操作同样会获得一个全新的版本（根节点变了，新的a!==旧的a），历史版本可以完好保留，同时也节约了空间和时间。\r\n位分区进行速度优化  （5层）\r\n树高压缩、节点内部压缩（Bitmap）进行空间优化\r\n\r\n\r\n\r\n疑问：\r\n    和const什么区别？\r\n    为什么不用深拷贝？\r\n        浪费内存，深度遍历频繁更新不优雅\r\n    Object.assign 的效率较低，因此在特殊场景，不适合使用 Object.assign 生成 immutable 数据。但是大部分场景还是完全可以使用 Object.assign 的。\r\n    \r\n */\r\nclass Immutatble extends React.Component{\r\n\r\n    constructor(props){\r\n        super(props);\r\n        this.props = props;\r\n        this.state={\r\n            count:0\r\n        }\r\n    }\r\n    handleDemo = () => {\r\n        let foo = {a:{b:1}};\r\n        let bar = foo;\r\n        bar.a.b = 2;\r\n        console.log(foo.a.b);\r\n        console.log(foo === bar);\r\n    }\r\n    setCount = () => {\r\n        this.setState({\r\n            count:this.state.count+1\r\n        })\r\n    }\r\n    \r\n    handleDemo2 = () => {\r\n        let foo = {a:{b:1}};\r\n        let bar = foo;\r\n        foo = Immutable.fromJS({a:{b:1}});\r\n        bar =  foo.setIn(['a','b'],2);\r\n        console.log(foo.getIn(['a','b']));\r\n        console.log(foo === bar);\r\n        console.log(bar.getIn(['a']));\r\n    //     let data = Immutable.fromJS({ a: { b: { c: 1 } } });\r\n    //     // 让 cursor 指向 { c: 1 }\r\n    //     let cursor = Cursor.from(data, ['a', 'b'], newData => {\r\n    //     // 当 cursor 或其子 cursor 执行 update 时调用\r\n    //     console.log(newData);\r\n    //     });\r\n\r\n    //    console.log(cursor.get('c')); // 1\r\n    //     cursor = cursor.update('c', x => x + 1);\r\n    //     console.log(cursor.get('c')); // 1\r\n    }\r\n\r\n    handleDemo3 = () => {\r\n        let a = Map({\r\n            select: 'users',\r\n            filter: Map({name: 'Cam'})\r\n        })\r\n        let b = a.set('select','people');\r\n        console.log(a === b);\r\n        console.log(a.get('filter') === b.get('filter'),a.get('filter'));\r\n        // a和b共享了没有变化的filter节点   ？？？？\r\n    }\r\n\r\n    handleDemo4 = () => {\r\n        // 1.formJS\r\n        let data = fromJS({a:{b:[12,10,20],c:{d:30,e:[12,21]}}},function(key,value,path){\r\n            console.log(key,value,path,isIndexed(value));\r\n            return isIndexed(value) ? value.toList() : value.toOrderedMap()\r\n        })\r\n        console.log(data.getIn(['a']));\r\n        // 2.isImmutable 返回true表示是不可变数据\r\n        const { isImmutable,isCollection,isKeyed,isAssociative,isOrdered, Map, List, Stack,Set,OrderedMap } = require('immutable');\r\n        isImmutable([]); // false\r\n        isImmutable({}); // false\r\n        isImmutable(Map()); // true\r\n        isImmutable(List()); // true\r\n        isImmutable(Stack()); // true\r\n        isImmutable(Map().asMutable()); // false\r\n        // 3.isCollection 返回true表示这是一个集合或者集合的子类\r\n        isCollection([]); // false\r\n        isCollection({}); // false\r\n        isCollection(Map()); // true\r\n        isCollection(List()); // true\r\n        isCollection(Stack()); // true\r\n        // 4.isKeyed 返回true表示这是Collection.key或其子类\r\n        isKeyed([]); // false\r\n        isKeyed({}); // false\r\n        isKeyed(Map()); // true\r\n        isKeyed(List()); // false\r\n        isKeyed(Stack()); // false\r\n        // 5.isIndexed 返回true表示这是Collection.isIndexed或其子类\r\n        isIndexed([]); // false\r\n        isIndexed({}); // false\r\n        isIndexed(Map()); // false\r\n        isIndexed(List()); // true\r\n        isIndexed(Stack()); // true\r\n        isIndexed(Set()); // false\r\n        // 6.isAssociative 返回true表示这是Keyed或者Indexed Collective(isKeyed+isIndexed)\r\n        isAssociative([]); // false\r\n        isAssociative({}); // false\r\n        isAssociative(Map()); // true\r\n        isAssociative(List()); // true\r\n        isAssociative(Stack()); // true\r\n        isAssociative(Set()); // false\r\n        // 7.isOrdered 返回true表示这是一个Collection同时迭代索引设置正确 Collection.indexed、OrderedMap和OrderedSet会返回True\r\n        isOrdered([]); // false\r\n        isOrdered({}); // false\r\n        isOrdered(Map()); // false\r\n        isOrdered(OrderedMap()); // true\r\n        isOrdered(List()); // true\r\n        isOrdered(Set()); // false\r\n        // 8.isValueObject 返回true表示这是个JS对象并且同时拥有equals()和hashCode()方法\r\n        //equals() // 当与传入的集合值相等时返回True，相等比较与Immutable.is()的定义一样\r\n        //hashCode() // 返回当前集合的哈希计算值。在添加一个元素到Set中或者用Key索引Map时，hashCode会被用于查明两个集合潜在的相等关系，即使他们没用相同的地址\r\n        const a = List([ 1, 2, 3 ]);\r\n        const b = List([ 1, 2, 3 ]);\r\n        console.log(a !== b); // 不是相同地址  true\r\n        const set = Set([ a ]);\r\n        console.log(set.has(b) === true); //true\r\n        // 当两个值的hashCode相等时，并不完全保证他们是相等的，但当他们的hashCode不同时，他们一定是不等的。\r\n        // List  List是类似于JS中数组的密集型有序集合。  List实现了队列功能，能高效的在队首(unshift, shift)或者队尾(push, pop)进行元素的添加和删除。\r\n        List.isList([]); // false\r\n        List.isList(List()); // true\r\n        // List.of()\r\n        List.of({x:1}, 2, [3], 4)// List [ { x: 1 }, 2, [ 3 ], 4 ]\r\n        // set  返回一个在index位置处值为value的新List。如果index位置已经定义了值，它将会被替换。\r\n        // delete,insert,clear,push,pop,unshift,shift,update等等\r\n        // toJS()  深层地将这个有序的集合转换为原生JS数组\r\n        // toJSON  浅转换这个有序的集合为原生JS数组\r\n    }\r\n\r\n    // Vector Trie 的核心\r\n    get = (shift,keyHash,key,notSetValue) => {\r\n        const {hash,MASK} = require(Immutable)\r\n        if(keyHash === undefined){\r\n            keyHash = hash(key);\r\n        }\r\n        const idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\r\n        const node = this.nodes[idx];\r\n        return node ? node.get(shift + shift,keyHash,key,notSetValue) : notSetValue;\r\n    }\r\n    render(){\r\n        // 1.原来的写法\r\n        // this.handleDemo();\r\n        // 2.使用 immutable.js后\r\n        // this.handleDemo2();\r\n        // 3.节省内存--复用内存\r\n        // this.handleDemo3();\r\n        // 4.API\r\n        this.handleDemo4();\r\n        const {count} = this.state\r\n        return (\r\n            <div>\r\n            <p>You clicked {count} times</p>\r\n            <button onClick={() => this.setCount()}>\r\n            Click me\r\n            </button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\nexport default Immutatble;","D:\\workspace\\create-pdman\\my_amad\\src\\App\\Immutable\\Demo1.js",["32"],"import { fromJS } from \"immutable\";\r\n\r\nconst defaultState  = fromJS({\r\n    todoList: []\r\n})",["33","34"],{"ruleId":"35","replacedBy":"36"},{"ruleId":"37","replacedBy":"38"},{"ruleId":"35","replacedBy":"39"},{"ruleId":"37","replacedBy":"40"},{"ruleId":"41","severity":1,"message":"42","line":4,"column":8,"nodeType":"43","messageId":"44","endLine":4,"endColumn":14},{"ruleId":"41","severity":1,"message":"45","line":3,"column":7,"nodeType":"43","messageId":"44","endLine":3,"endColumn":19},{"ruleId":"35","replacedBy":"46"},{"ruleId":"37","replacedBy":"47"},"no-native-reassign",["48"],"no-negated-in-lhs",["49"],["48"],["49"],"no-unused-vars","'Cursor' is defined but never used.","Identifier","unusedVar","'defaultState' is assigned a value but never used.",["48"],["49"],"no-global-assign","no-unsafe-negation"]